--[[
    ███████╗ █████╗ ███╗   ███╗██╗   ██╗██╗   ██╗    ███████╗██╗  ██╗██████╗ ██╗      ██████╗ ██╗████████╗
    ██╔════╝██╔══██╗████╗ ████║╚██╗ ██╔╝╚██╗ ██╔╝    ██╔════╝╚██╗██╔╝██╔══██╗██║     ██╔═══██╗██║╚══██╔══╝
    █████╗  ███████║██╔████╔██║ ╚████╔╝  ╚████╔╝     █████╗   ╚███╔╝ ██████╔╝██║     ██║   ██║██║   ██║   
    ██╔══╝  ██╔══██║██║╚██╔╝██║  ╚██╔╝    ╚██╔╝      ██╔══╝   ██╔██╗ ██╔═══╝ ██║     ██║   ██║██║   ██║   
    ██║     ██║  ██║██║ ╚═╝ ██║   ██║      ██║       ███████╗██╔╝ ██╗██║     ███████╗╚██████╔╝██║   ██║   
    ╚═╝     ╚═╝  ╚═╝╚═╝     ╚═╝   ╚═╝      ╚═╝       ╚══════╝╚═╝  ╚═╝╚═╝     ╚══════╝ ╚═════╝ ╚═╝   ╚═╝   
    
    FAMYY PRIVATE - Universal Game Exploit Scanner & Dumper v2.0
    
    FEATURES:
    - Dumps ALL remotes, services, and game structure
    - Auto-tests currency manipulation
    - Checks for admin panels/commands
    - Tests common remote exploits
    - Detects anti-cheat systems
    - Tests player modifications (speed, jump, fly)
    - Finds potential backdoors
    - Tests datastore manipulation
    - Comprehensive vulnerability report
]]

-- ============================================================================
-- SERVICES
-- ============================================================================
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace = game:GetService("Workspace")
local Lighting = game:GetService("Lighting")
local ServerStorage = game:GetService("ServerStorage")
local ServerScriptService = game:GetService("ServerScriptService")
local StarterGui = game:GetService("StarterGui")
local StarterPack = game:GetService("StarterPack")
local StarterPlayer = game:GetService("StarterPlayer")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")
local MarketplaceService = game:GetService("MarketplaceService")
local HttpService = game:GetService("HttpService")
local TeleportService = game:GetService("TeleportService")
local SoundService = game:GetService("SoundService")
local Chat = game:GetService("Chat")
local Teams = game:GetService("Teams")

local LocalPlayer = Players.LocalPlayer
local Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()

-- ============================================================================
-- OUTPUT STORAGE
-- ============================================================================
local Results = {
    GameInfo = {},
    Remotes = {Events = {}, Functions = {}},
    PlayerData = {},
    Currency = {},
    AdminPanel = {},
    Vulnerabilities = {},
    AntiCheat = {},
    Exploits = {},
    Items = {},
    NPCs = {},
    Shops = {},
}

local TestResults = {
    CurrencyManipulation = {},
    SpeedHack = {Working = false},
    JumpHack = {Working = false},
    NoClip = {Working = false},
    Fly = {Working = false},
    AdminAccess = {Working = false},
    RemoteSpam = {},
    DatastoreAccess = {},
}

-- ============================================================================
-- UTILITY FUNCTIONS
-- ============================================================================
local function SafeCall(func)
    local success, result = pcall(func)
    return success, result
end

local function Log(category, message)
    print("[FAMYY EXPLOIT] [" .. category .. "] " .. tostring(message))
end

local function Warn(category, message)
    warn("[FAMYY EXPLOIT] [" .. category .. "] " .. tostring(message))
end

local function Success(category, message)
    print("[FAMYY EXPLOIT] [SUCCESS] [" .. category .. "] " .. tostring(message))
end

local function GetPath(obj)
    local path = obj.Name
    local parent = obj.Parent
    while parent and parent ~= game do
        path = parent.Name .. "." .. path
        parent = parent.Parent
    end
    return path
end

-- ============================================================================
-- GAME INFO
-- ============================================================================
local function DumpGameInfo()
    Log("INFO", "Gathering game information...")
    
    Results.GameInfo = {
        PlaceId = game.PlaceId,
        PlaceVersion = game.PlaceVersion,
        GameId = game.GameId,
        JobId = game.JobId,
        CreatorId = game.CreatorId,
        CreatorType = tostring(game.CreatorType),
        PrivateServerId = game.PrivateServerId,
        PrivateServerOwnerId = game.PrivateServerOwnerId,
        PlayerCount = #Players:GetPlayers(),
        MaxPlayers = Players.MaxPlayers,
    }
    
    -- Try to get game name
    pcall(function()
        local info = MarketplaceService:GetProductInfo(game.PlaceId)
        Results.GameInfo.GameName = info.Name
        Results.GameInfo.Description = info.Description
        Results.GameInfo.Creator = info.Creator.Name
    end)
    
    Log("INFO", "Game: " .. (Results.GameInfo.GameName or "Unknown"))
    Log("INFO", "PlaceId: " .. Results.GameInfo.PlaceId)
end

-- ============================================================================
-- REMOTE DUMPER
-- ============================================================================
local function DumpRemotes()
    Log("REMOTES", "Scanning for RemoteEvents and RemoteFunctions...")
    
    local remoteCount = 0
    local functionCount = 0
    
    local function ScanForRemotes(parent)
        for _, obj in pairs(parent:GetDescendants()) do
            pcall(function()
                if obj:IsA("RemoteEvent") then
                    table.insert(Results.Remotes.Events, {
                        Name = obj.Name,
                        Path = GetPath(obj),
                        Parent = obj.Parent.Name
                    })
                    remoteCount = remoteCount + 1
                elseif obj:IsA("RemoteFunction") then
                    table.insert(Results.Remotes.Functions, {
                        Name = obj.Name,
                        Path = GetPath(obj),
                        Parent = obj.Parent.Name
                    })
                    functionCount = functionCount + 1
                end
            end)
        end
    end
    
    -- Scan common locations
    ScanForRemotes(ReplicatedStorage)
    ScanForRemotes(Workspace)
    ScanForRemotes(Lighting)
    pcall(function() ScanForRemotes(game:GetService("ReplicatedFirst")) end)
    
    Log("REMOTES", "Found " .. remoteCount .. " RemoteEvents")
    Log("REMOTES", "Found " .. functionCount .. " RemoteFunctions")
end

-- ============================================================================
-- PLAYER DATA DUMPER
-- ============================================================================
local function DumpPlayerData()
    Log("PLAYER", "Scanning player data...")
    
    -- Check leaderstats
    local leaderstats = LocalPlayer:FindFirstChild("leaderstats")
    if leaderstats then
        Results.PlayerData.Leaderstats = {}
        for _, stat in pairs(leaderstats:GetChildren()) do
            Results.PlayerData.Leaderstats[stat.Name] = {
                Value = stat.Value,
                ClassName = stat.ClassName
            }
            Log("PLAYER", "Leaderstat: " .. stat.Name .. " = " .. tostring(stat.Value))
        end
    end
    
    -- Check Data folder (common pattern)
    local dataFolder = LocalPlayer:FindFirstChild("Data")
    if dataFolder then
        Results.PlayerData.Data = {}
        for _, data in pairs(dataFolder:GetChildren()) do
            if data:IsA("ValueBase") then
                Results.PlayerData.Data[data.Name] = {
                    Value = data.Value,
                    ClassName = data.ClassName
                }
                Log("PLAYER", "Data: " .. data.Name .. " = " .. tostring(data.Value))
            end
        end
    end
    
    -- Check PlayerData folder
    local playerData = LocalPlayer:FindFirstChild("PlayerData")
    if playerData then
        Results.PlayerData.PlayerData = {}
        for _, data in pairs(playerData:GetChildren()) do
            if data:IsA("ValueBase") then
                Results.PlayerData.PlayerData[data.Name] = {
                    Value = data.Value,
                    ClassName = data.ClassName
                }
            end
        end
    end
    
    -- Check Stats folder
    local stats = LocalPlayer:FindFirstChild("Stats")
    if stats then
        Results.PlayerData.Stats = {}
        for _, stat in pairs(stats:GetChildren()) do
            if stat:IsA("ValueBase") then
                Results.PlayerData.Stats[stat.Name] = {
                    Value = stat.Value,
                    ClassName = stat.ClassName
                }
            end
        end
    end
    
    -- Scan for any ValueBase in player
    Results.PlayerData.AllValues = {}
    for _, obj in pairs(LocalPlayer:GetDescendants()) do
        if obj:IsA("ValueBase") then
            table.insert(Results.PlayerData.AllValues, {
                Name = obj.Name,
                Value = obj.Value,
                Path = GetPath(obj),
                ClassName = obj.ClassName
            })
        end
    end
    
    Log("PLAYER", "Found " .. #Results.PlayerData.AllValues .. " total values in player")
end

-- ============================================================================
-- CURRENCY DETECTION & TESTING
-- ============================================================================
local CurrencyKeywords = {"Cash", "Money", "Coins", "Gold", "Gems", "Diamonds", "Credits", "Points", "Beli", "Yen", "Robux", "Currency", "Balance", "Wallet", "Bank", "Tokens", "Stars", "Crystals", "Souls", "Energy", "Power", "XP", "EXP", "Level", "Strength", "Fragment"}

local function DetectCurrency()
    Log("CURRENCY", "Detecting currency values...")
    
    Results.Currency = {}
    
    -- Scan leaderstats
    local leaderstats = LocalPlayer:FindFirstChild("leaderstats")
    if leaderstats then
        for _, stat in pairs(leaderstats:GetChildren()) do
            for _, keyword in pairs(CurrencyKeywords) do
                if stat.Name:lower():find(keyword:lower()) then
                    table.insert(Results.Currency, {
                        Name = stat.Name,
                        Value = stat.Value,
                        Path = GetPath(stat),
                        ClassName = stat.ClassName,
                        Location = "leaderstats"
                    })
                    Log("CURRENCY", "Found: " .. stat.Name .. " = " .. tostring(stat.Value))
                    break
                end
            end
        end
    end
    
    -- Scan Data folder
    local dataFolder = LocalPlayer:FindFirstChild("Data")
    if dataFolder then
        for _, data in pairs(dataFolder:GetDescendants()) do
            if data:IsA("ValueBase") then
                for _, keyword in pairs(CurrencyKeywords) do
                    if data.Name:lower():find(keyword:lower()) then
                        table.insert(Results.Currency, {
                            Name = data.Name,
                            Value = data.Value,
                            Path = GetPath(data),
                            ClassName = data.ClassName,
                            Location = "Data"
                        })
                        Log("CURRENCY", "Found: " .. data.Name .. " = " .. tostring(data.Value))
                        break
                    end
                end
            end
        end
    end
end

local function TestCurrencyManipulation()
    Log("TEST", "Testing currency manipulation...")
    
    TestResults.CurrencyManipulation = {}
    
    for _, currency in pairs(Results.Currency) do
        local obj = nil
        
        -- Find the object
        pcall(function()
            local path = currency.Path:split(".")
            obj = game
            for _, part in pairs(path) do
                obj = obj:FindFirstChild(part)
            end
        end)
        
        if obj and obj:IsA("ValueBase") then
            local originalValue = obj.Value
            local testValue = originalValue + 999999
            
            -- Try to modify
            local success = pcall(function()
                obj.Value = testValue
            end)
            
            task.wait(0.1)
            
            local worked = obj.Value == testValue
            
            table.insert(TestResults.CurrencyManipulation, {
                Name = currency.Name,
                CanModify = success,
                ValueChanged = worked,
                OriginalValue = originalValue,
                AttemptedValue = testValue,
                CurrentValue = obj.Value
            })
            
            if worked then
                Success("CURRENCY", currency.Name .. " CAN BE MODIFIED! (Client-side)")
                -- Restore original value
                pcall(function() obj.Value = originalValue end)
            else
                Log("TEST", currency.Name .. " - Server-protected")
            end
        end
    end
end

-- ============================================================================
-- ADMIN PANEL DETECTION
-- ============================================================================
local AdminKeywords = {"Admin", "Cmds", "Commands", "Panel", "Mod", "Staff", "Owner", "Developer", "Debug", "Console", "Terminal", "Control", "Manage", "Backdoor", "HD", "Infinite Yield", "Kohls", "Adonis", "Basic Admin"}

local function DetectAdminPanels()
    Log("ADMIN", "Scanning for admin panels...")
    
    Results.AdminPanel = {
        Found = false,
        Panels = {},
        Commands = {},
        Backdoors = {}
    }
    
    -- Check PlayerGui
    local playerGui = LocalPlayer:FindFirstChild("PlayerGui")
    if playerGui then
        for _, gui in pairs(playerGui:GetDescendants()) do
            for _, keyword in pairs(AdminKeywords) do
                if gui.Name:lower():find(keyword:lower()) then
                    table.insert(Results.AdminPanel.Panels, {
                        Name = gui.Name,
                        Path = GetPath(gui),
                        ClassName = gui.ClassName
                    })
                    Results.AdminPanel.Found = true
                    Warn("ADMIN", "Found potential admin GUI: " .. gui.Name)
                    break
                end
            end
        end
    end
    
    -- Check ReplicatedStorage for admin modules
    for _, obj in pairs(ReplicatedStorage:GetDescendants()) do
        for _, keyword in pairs(AdminKeywords) do
            if obj.Name:lower():find(keyword:lower()) then
                table.insert(Results.AdminPanel.Panels, {
                    Name = obj.Name,
                    Path = GetPath(obj),
                    ClassName = obj.ClassName
                })
                Warn("ADMIN", "Found in ReplicatedStorage: " .. obj.Name)
                break
            end
        end
    end
    
    -- Check for common backdoor patterns
    local backdoorPatterns = {"require", "loadstring", "HttpGet", "getfenv", "setfenv", "rawget", "rawset"}
    for _, script in pairs(game:GetDescendants()) do
        if script:IsA("ModuleScript") then
            for _, pattern in pairs(backdoorPatterns) do
                if script.Name:lower():find(pattern:lower()) then
                    table.insert(Results.AdminPanel.Backdoors, {
                        Name = script.Name,
                        Path = GetPath(script)
                    })
                    Warn("ADMIN", "Potential backdoor module: " .. script.Name)
                    break
                end
            end
        end
    end
end

local function TestAdminCommands()
    Log("TEST", "Testing common admin commands...")
    
    local chatRemote = ReplicatedStorage:FindFirstChild("DefaultChatSystemChatEvents")
    if chatRemote then
        local sayMessage = chatRemote:FindFirstChild("SayMessageRequest")
        if sayMessage then
            -- Test common admin commands
            local commands = {":cmds", "/cmds", "!cmds", ":admin", "/admin", ":help", "!help", ":fly", ":speed 100", ":god", ":kill all"}
            
            for _, cmd in pairs(commands) do
                pcall(function()
                    sayMessage:FireServer(cmd, "All")
                end)
                task.wait(0.2)
            end
            
            Log("TEST", "Tested " .. #commands .. " admin commands")
        end
    end
end

-- ============================================================================
-- ANTI-CHEAT DETECTION
-- ============================================================================
local function DetectAntiCheat()
    Log("ANTICHEAT", "Detecting anti-cheat systems...")
    
    Results.AntiCheat = {
        Detected = false,
        Systems = {},
        Hooks = {}
    }
    
    local antiCheatKeywords = {"AntiCheat", "AntiExploit", "Security", "Kick", "Ban", "Detect", "Exploit", "Hack", "Cheat", "Validator", "Check", "Monitor", "Guard", "Protect", "Shield"}
    
    -- Scan for anti-cheat scripts
    for _, obj in pairs(game:GetDescendants()) do
        if obj:IsA("LocalScript") or obj:IsA("ModuleScript") then
            for _, keyword in pairs(antiCheatKeywords) do
                if obj.Name:lower():find(keyword:lower()) then
                    table.insert(Results.AntiCheat.Systems, {
                        Name = obj.Name,
                        Path = GetPath(obj),
                        ClassName = obj.ClassName
                    })
                    Results.AntiCheat.Detected = true
                    Warn("ANTICHEAT", "Found: " .. obj.Name)
                    break
                end
            end
        end
    end
    
    -- Check for common anti-cheat remotes
    for _, remote in pairs(Results.Remotes.Events) do
        for _, keyword in pairs(antiCheatKeywords) do
            if remote.Name:lower():find(keyword:lower()) then
                table.insert(Results.AntiCheat.Hooks, remote)
                Warn("ANTICHEAT", "Remote: " .. remote.Name)
                break
            end
        end
    end
    
    if Results.AntiCheat.Detected then
        Warn("ANTICHEAT", "Anti-cheat system detected! Be careful with exploits.")
    else
        Success("ANTICHEAT", "No obvious anti-cheat detected")
    end
end

-- ============================================================================
-- PLAYER MODIFICATION TESTS
-- ============================================================================
local function TestSpeedHack()
    Log("TEST", "Testing speed modification...")
    
    local humanoid = Character:FindFirstChildOfClass("Humanoid")
    if humanoid then
        local originalSpeed = humanoid.WalkSpeed
        
        pcall(function()
            humanoid.WalkSpeed = 100
        end)
        
        task.wait(0.5)
        
        TestResults.SpeedHack = {
            Working = humanoid.WalkSpeed == 100,
            OriginalSpeed = originalSpeed,
            CurrentSpeed = humanoid.WalkSpeed
        }
        
        if TestResults.SpeedHack.Working then
            Success("SPEED", "Speed hack WORKS! Set to 100")
        else
            Log("TEST", "Speed hack blocked or reset by server")
            pcall(function() humanoid.WalkSpeed = originalSpeed end)
        end
    end
end

local function TestJumpHack()
    Log("TEST", "Testing jump power modification...")
    
    local humanoid = Character:FindFirstChildOfClass("Humanoid")
    if humanoid then
        local originalPower = humanoid.JumpPower
        
        pcall(function()
            humanoid.JumpPower = 200
            humanoid.UseJumpPower = true
        end)
        
        task.wait(0.5)
        
        TestResults.JumpHack = {
            Working = humanoid.JumpPower == 200,
            OriginalPower = originalPower,
            CurrentPower = humanoid.JumpPower
        }
        
        if TestResults.JumpHack.Working then
            Success("JUMP", "Jump hack WORKS! Set to 200")
        else
            Log("TEST", "Jump hack blocked or reset by server")
        end
    end
end

local function TestNoClip()
    Log("TEST", "Testing NoClip...")
    
    local worked = false
    local connection
    
    connection = RunService.Stepped:Connect(function()
        pcall(function()
            for _, part in pairs(Character:GetDescendants()) do
                if part:IsA("BasePart") then
                    part.CanCollide = false
                end
            end
        end)
    end)
    
    task.wait(1)
    
    -- Check if it's still working
    local hrp = Character:FindFirstChild("HumanoidRootPart")
    if hrp then
        worked = hrp.CanCollide == false
    end
    
    connection:Disconnect()
    
    TestResults.NoClip = {
        Working = worked
    }
    
    if worked then
        Success("NOCLIP", "NoClip WORKS!")
    else
        Log("TEST", "NoClip may be blocked")
    end
end

local function TestFly()
    Log("TEST", "Testing Fly...")
    
    local hrp = Character:FindFirstChild("HumanoidRootPart")
    if hrp then
        local bv = Instance.new("BodyVelocity")
        bv.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
        bv.Velocity = Vector3.new(0, 50, 0)
        
        local success = pcall(function()
            bv.Parent = hrp
        end)
        
        task.wait(0.5)
        
        local stillExists = hrp:FindFirstChildOfClass("BodyVelocity") ~= nil
        
        TestResults.Fly = {
            Working = success and stillExists
        }
        
        pcall(function() bv:Destroy() end)
        
        if TestResults.Fly.Working then
            Success("FLY", "Fly WORKS! (BodyVelocity)")
        else
            Log("TEST", "Fly blocked or removed by server")
        end
    end
end

-- ============================================================================
-- REMOTE EXPLOIT TESTING
-- ============================================================================
local function TestRemoteExploits()
    Log("TEST", "Testing remote exploits...")
    
    TestResults.RemoteSpam = {}
    
    -- Find interesting remotes
    local interestingKeywords = {"Buy", "Purchase", "Give", "Add", "Set", "Reward", "Claim", "Collect", "Get", "Spawn", "Create", "Unlock", "Upgrade"}
    
    for _, remote in pairs(Results.Remotes.Events) do
        for _, keyword in pairs(interestingKeywords) do
            if remote.Name:lower():find(keyword:lower()) then
                Log("REMOTE", "Interesting remote: " .. remote.Name .. " (" .. remote.Path .. ")")
                
                table.insert(Results.Exploits, {
                    Type = "RemoteEvent",
                    Name = remote.Name,
                    Path = remote.Path,
                    Keyword = keyword,
                    TestCommand = 'game.' .. remote.Path .. ':FireServer()'
                })
                break
            end
        end
    end
    
    for _, remote in pairs(Results.Remotes.Functions) do
        for _, keyword in pairs(interestingKeywords) do
            if remote.Name:lower():find(keyword:lower()) then
                Log("REMOTE", "Interesting function: " .. remote.Name .. " (" .. remote.Path .. ")")
                
                table.insert(Results.Exploits, {
                    Type = "RemoteFunction",
                    Name = remote.Name,
                    Path = remote.Path,
                    Keyword = keyword,
                    TestCommand = 'game.' .. remote.Path .. ':InvokeServer()'
                })
                break
            end
        end
    end
    
    Log("TEST", "Found " .. #Results.Exploits .. " potentially exploitable remotes")
end

-- ============================================================================
-- ITEM/NPC SCANNING
-- ============================================================================
local function ScanItems()
    Log("ITEMS", "Scanning for items and tools...")
    
    Results.Items = {}
    
    -- Check Backpack
    local backpack = LocalPlayer:FindFirstChild("Backpack")
    if backpack then
        for _, item in pairs(backpack:GetChildren()) do
            if item:IsA("Tool") then
                table.insert(Results.Items, {
                    Name = item.Name,
                    Location = "Backpack",
                    ClassName = item.ClassName
                })
            end
        end
    end
    
    -- Check Workspace for items
    for _, obj in pairs(Workspace:GetDescendants()) do
        if obj:IsA("Tool") then
            table.insert(Results.Items, {
                Name = obj.Name,
                Location = GetPath(obj),
                ClassName = obj.ClassName
            })
        end
    end
    
    Log("ITEMS", "Found " .. #Results.Items .. " items/tools")
end

local function ScanNPCs()
    Log("NPCs", "Scanning for NPCs...")
    
    Results.NPCs = {}
    
    local npcKeywords = {"NPC", "Shop", "Vendor", "Quest", "Merchant", "Dealer", "Trainer", "Guard", "Enemy", "Boss", "Mob"}
    
    for _, obj in pairs(Workspace:GetDescendants()) do
        if obj:IsA("Model") and obj:FindFirstChildOfClass("Humanoid") then
            local isNPC = false
            
            -- Check if it's a player character
            local isPlayer = false
            for _, player in pairs(Players:GetPlayers()) do
                if player.Character == obj then
                    isPlayer = true
                    break
                end
            end
            
            if not isPlayer then
                for _, keyword in pairs(npcKeywords) do
                    if obj.Name:lower():find(keyword:lower()) then
                        isNPC = true
                        break
                    end
                end
                
                -- Also consider any humanoid not a player as NPC
                local humanoid = obj:FindFirstChildOfClass("Humanoid")
                if humanoid then
                    local hrp = obj:FindFirstChild("HumanoidRootPart")
                    table.insert(Results.NPCs, {
                        Name = obj.Name,
                        Health = humanoid.Health,
                        MaxHealth = humanoid.MaxHealth,
                        Position = hrp and tostring(hrp.Position) or "Unknown",
                        Path = GetPath(obj)
                    })
                end
            end
        end
    end
    
    Log("NPCs", "Found " .. #Results.NPCs .. " NPCs/entities")
end

-- ============================================================================
-- SHOP DETECTION
-- ============================================================================
local function ScanShops()
    Log("SHOPS", "Scanning for shops...")
    
    Results.Shops = {}
    
    local shopKeywords = {"Shop", "Store", "Buy", "Purchase", "Market", "Vendor", "Merchant", "Trade", "Exchange"}
    
    -- Check GUIs
    local playerGui = LocalPlayer:FindFirstChild("PlayerGui")
    if playerGui then
        for _, gui in pairs(playerGui:GetDescendants()) do
            for _, keyword in pairs(shopKeywords) do
                if gui.Name:lower():find(keyword:lower()) then
                    table.insert(Results.Shops, {
                        Name = gui.Name,
                        Path = GetPath(gui),
                        Type = "GUI"
                    })
                    break
                end
            end
        end
    end
    
    -- Check remotes for shop functions
    for _, remote in pairs(Results.Remotes.Events) do
        for _, keyword in pairs(shopKeywords) do
            if remote.Name:lower():find(keyword:lower()) then
                table.insert(Results.Shops, {
                    Name = remote.Name,
                    Path = remote.Path,
                    Type = "Remote"
                })
                break
            end
        end
    end
    
    Log("SHOPS", "Found " .. #Results.Shops .. " shop-related objects")
end

-- ============================================================================
-- GENERATE REPORT
-- ============================================================================
local function GenerateReport()
    print("\n")
    print("================================================================================")
    print("                    FAMYY PRIVATE - EXPLOIT SCAN REPORT")
    print("================================================================================")
    print("")
    
    -- Game Info
    print("=== GAME INFO ===")
    print("Game: " .. (Results.GameInfo.GameName or "Unknown"))
    print("PlaceId: " .. Results.GameInfo.PlaceId)
    print("Players: " .. Results.GameInfo.PlayerCount .. "/" .. Results.GameInfo.MaxPlayers)
    print("")
    
    -- Remotes
    print("=== REMOTES ===")
    print("RemoteEvents: " .. #Results.Remotes.Events)
    print("RemoteFunctions: " .. #Results.Remotes.Functions)
    print("")
    
    -- Currency
    print("=== CURRENCY DETECTED ===")
    for _, c in pairs(Results.Currency) do
        print("  " .. c.Name .. " = " .. tostring(c.Value) .. " (" .. c.Location .. ")")
    end
    print("")
    
    -- Currency Test Results
    print("=== CURRENCY MANIPULATION TEST ===")
    for _, test in pairs(TestResults.CurrencyManipulation) do
        local status = test.ValueChanged and "VULNERABLE (Client-side)" or "Protected"
        print("  " .. test.Name .. ": " .. status)
    end
    print("")
    
    -- Player Mod Tests
    print("=== PLAYER MODIFICATION TESTS ===")
    print("  Speed Hack: " .. (TestResults.SpeedHack.Working and "WORKING" or "Blocked"))
    print("  Jump Hack: " .. (TestResults.JumpHack.Working and "WORKING" or "Blocked"))
    print("  NoClip: " .. (TestResults.NoClip.Working and "WORKING" or "Blocked"))
    print("  Fly: " .. (TestResults.Fly.Working and "WORKING" or "Blocked"))
    print("")
    
    -- Anti-Cheat
    print("=== ANTI-CHEAT ===")
    if Results.AntiCheat.Detected then
        print("  Status: DETECTED")
        for _, ac in pairs(Results.AntiCheat.Systems) do
            print("    - " .. ac.Name)
        end
    else
        print("  Status: Not detected")
    end
    print("")
    
    -- Admin Panels
    print("=== ADMIN PANELS ===")
    if Results.AdminPanel.Found then
        print("  Status: FOUND")
        for _, panel in pairs(Results.AdminPanel.Panels) do
            print("    - " .. panel.Name .. " (" .. panel.ClassName .. ")")
        end
    else
        print("  Status: Not found")
    end
    print("")
    
    -- Exploitable Remotes
    print("=== POTENTIALLY EXPLOITABLE REMOTES ===")
    for i, exploit in pairs(Results.Exploits) do
        if i <= 20 then -- Limit output
            print("  " .. exploit.Name .. " [" .. exploit.Keyword .. "]")
            print("    " .. exploit.TestCommand)
        end
    end
    if #Results.Exploits > 20 then
        print("  ... and " .. (#Results.Exploits - 20) .. " more")
    end
    print("")
    
    -- NPCs
    print("=== NPCs/ENTITIES ===")
    print("  Total: " .. #Results.NPCs)
    for i, npc in pairs(Results.NPCs) do
        if i <= 10 then
            print("    " .. npc.Name .. " [HP: " .. npc.Health .. "/" .. npc.MaxHealth .. "]")
        end
    end
    print("")
    
    -- Summary
    print("=== VULNERABILITY SUMMARY ===")
    local vulnCount = 0
    if TestResults.SpeedHack.Working then vulnCount = vulnCount + 1; print("  [!] Speed hack works") end
    if TestResults.JumpHack.Working then vulnCount = vulnCount + 1; print("  [!] Jump hack works") end
    if TestResults.NoClip.Working then vulnCount = vulnCount + 1; print("  [!] NoClip works") end
    if TestResults.Fly.Working then vulnCount = vulnCount + 1; print("  [!] Fly works") end
    for _, test in pairs(TestResults.CurrencyManipulation) do
        if test.ValueChanged then 
            vulnCount = vulnCount + 1
            print("  [!] " .. test.Name .. " can be modified client-side")
        end
    end
    if not Results.AntiCheat.Detected then vulnCount = vulnCount + 1; print("  [!] No anti-cheat detected") end
    
    print("")
    print("Total vulnerabilities found: " .. vulnCount)
    print("================================================================================")
    print("")
    
    return Results, TestResults
end

-- ============================================================================
-- EXPORT DATA (Auto-copy to clipboard)
-- ============================================================================
local function ExportAsLua()
    local output = {}
    
    table.insert(output, "-- FAMYY PRIVATE - Game Data Export")
    table.insert(output, "-- Game: " .. (Results.GameInfo.GameName or "Unknown"))
    table.insert(output, "-- PlaceId: " .. Results.GameInfo.PlaceId)
    table.insert(output, "-- Generated: " .. os.date("%Y-%m-%d %H:%M:%S"))
    table.insert(output, "")
    table.insert(output, "local GameData = {")
    table.insert(output, "    PlaceId = " .. Results.GameInfo.PlaceId .. ",")
    table.insert(output, "    GameName = \"" .. (Results.GameInfo.GameName or "Unknown") .. "\",")
    table.insert(output, "")
    
    -- Currency
    table.insert(output, "    Currency = {")
    for _, c in pairs(Results.Currency) do
        table.insert(output, "        {Name = \"" .. c.Name .. "\", Path = \"" .. c.Path .. "\", Value = " .. tostring(c.Value) .. "},")
    end
    table.insert(output, "    },")
    table.insert(output, "")
    
    -- Useful Remotes
    table.insert(output, "    Remotes = {")
    for i, remote in pairs(Results.Remotes.Events) do
        if i <= 50 then
            table.insert(output, "        {Type = \"Event\", Name = \"" .. remote.Name .. "\", Path = \"" .. remote.Path .. "\"},")
        end
    end
    for i, remote in pairs(Results.Remotes.Functions) do
        if i <= 50 then
            table.insert(output, "        {Type = \"Function\", Name = \"" .. remote.Name .. "\", Path = \"" .. remote.Path .. "\"},")
        end
    end
    table.insert(output, "    },")
    table.insert(output, "")
    
    -- Exploitable Remotes
    table.insert(output, "    ExploitableRemotes = {")
    for i, exploit in pairs(Results.Exploits) do
        if i <= 30 then
            table.insert(output, "        {Name = \"" .. exploit.Name .. "\", Path = \"" .. exploit.Path .. "\", Keyword = \"" .. exploit.Keyword .. "\"},")
        end
    end
    table.insert(output, "    },")
    table.insert(output, "")
    
    -- NPCs
    table.insert(output, "    NPCs = {")
    for i, npc in pairs(Results.NPCs) do
        if i <= 30 then
            table.insert(output, "        {Name = \"" .. npc.Name .. "\", Health = " .. npc.Health .. ", MaxHealth = " .. npc.MaxHealth .. ", Path = \"" .. npc.Path .. "\"},")
        end
    end
    table.insert(output, "    },")
    table.insert(output, "")
    
    -- Test Results
    table.insert(output, "    TestResults = {")
    table.insert(output, "        SpeedHack = " .. tostring(TestResults.SpeedHack.Working) .. ",")
    table.insert(output, "        JumpHack = " .. tostring(TestResults.JumpHack.Working) .. ",")
    table.insert(output, "        NoClip = " .. tostring(TestResults.NoClip.Working) .. ",")
    table.insert(output, "        Fly = " .. tostring(TestResults.Fly.Working) .. ",")
    table.insert(output, "        AntiCheatDetected = " .. tostring(Results.AntiCheat.Detected) .. ",")
    table.insert(output, "    },")
    table.insert(output, "}")
    table.insert(output, "")
    table.insert(output, "return GameData")
    
    local finalOutput = table.concat(output, "\n")
    
    -- Auto-copy to clipboard
    local copied = false
    
    -- Method 1: setclipboard (most executors)
    if setclipboard then
        pcall(function()
            setclipboard(finalOutput)
            copied = true
        end)
    end
    
    -- Method 2: toclipboard (some executors)
    if not copied and toclipboard then
        pcall(function()
            toclipboard(finalOutput)
            copied = true
        end)
    end
    
    -- Method 3: Synapse
    if not copied and syn and syn.write_clipboard then
        pcall(function()
            syn.write_clipboard(finalOutput)
            copied = true
        end)
    end
    
    -- Method 4: Fluxus/Krnl
    if not copied and writeclipboard then
        pcall(function()
            writeclipboard(finalOutput)
            copied = true
        end)
    end
    
    if copied then
        print("")
        print("================================================================================")
        print("    [SUCCESS] DATA COPIED TO CLIPBOARD!")
        print("    Paste it anywhere (Ctrl+V) to use the exported data.")
        print("================================================================================")
        print("")
    else
        print("")
        print("================================================================================")
        print("    [WARNING] Could not copy to clipboard. Printing data instead:")
        print("================================================================================")
        print("")
        print(finalOutput)
    end
    
    return finalOutput
end

-- ============================================================================
-- MAIN EXECUTION
-- ============================================================================
local function RunFullScan()
    print("")
    print("================================================================================")
    print("         FAMYY PRIVATE - Universal Game Exploit Scanner v2.0")
    print("================================================================================")
    print("")
    
    -- Dump phase
    DumpGameInfo()
    DumpRemotes()
    DumpPlayerData()
    DetectCurrency()
    DetectAdminPanels()
    DetectAntiCheat()
    ScanItems()
    ScanNPCs()
    ScanShops()
    
    print("")
    print("=== STARTING EXPLOIT TESTS ===")
    print("")
    
    -- Test phase
    TestCurrencyManipulation()
    TestSpeedHack()
    TestJumpHack()
    TestNoClip()
    TestFly()
    TestRemoteExploits()
    
    -- Generate report
    local results, testResults = GenerateReport()
    
    -- Export data
    ExportAsLua()
    
    print("")
    print("[FAMYY EXPLOIT] Scan complete!")
    print("[FAMYY EXPLOIT] Use the data above to create a custom script for this game.")
    print("")
    
    return results, testResults
end

-- Run the scan
return RunFullScan()
